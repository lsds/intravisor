#include <yaml.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "intravisor.h"

int debug = 0;

/*
 * Convert a yaml boolean string to a boolean value (true|false).
 */
int get_boolean(const char *string, bool *value) {
	char *t[] = { "y", "Y", "yes", "Yes", "YES", "true", "True", "TRUE", "on", "On", "ON", NULL };
	char *f[] = { "n", "N", "no", "No", "NO", "false", "False", "FALSE", "off", "Off", "OFF", NULL };
	char **p;

	for(p = t; *p; p++) {
		if(strcmp(string, *p) == 0) {
			*value = true;
			return 0;
		}
	}
	for(p = f; *p; p++) {
		if(strcmp(string, *p) == 0) {
			*value = false;
			return 0;
		}
	}
	return EINVAL;
}

/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c data structures. Error processing
 * is keep to a mimimum since this is just an example.
 */
int consume_event(struct parser_state *s, yaml_event_t * event) {
	char *value;

	if(debug) {
		printf("state=%d event=%d\n", s->state, event->type);
	}
	switch (s->state) {
	case STATE_START:
		switch (event->type) {
		case YAML_STREAM_START_EVENT:
			s->state = STATE_STREAM;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_STREAM:
		switch (event->type) {
		case YAML_DOCUMENT_START_EVENT:
			s->state = STATE_DOCUMENT;
			break;
		case YAML_STREAM_END_EVENT:
			s->state = STATE_STOP;	/* All done. */
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_DOCUMENT:
		switch (event->type) {
		case YAML_MAPPING_START_EVENT:
			s->state = STATE_SECTION;
			break;
		case YAML_DOCUMENT_END_EVENT:
			s->state = STATE_STREAM;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_SECTION:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			value = (char *) event->data.scalar.value;
			if(strcmp(value, "cVMs") == 0) {
				s->state = STATE_FLIST;
			} else if(strcmp(value, "capfiles") == 0) {
				s->state = STATE_CLIST;
			} else {
				fprintf(stderr, "Unexpected scalar: %s\n", value);
				return FAILURE;
			}
			break;
		case YAML_DOCUMENT_END_EVENT:
			s->state = STATE_STREAM;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FLIST:
		switch (event->type) {
		case YAML_SEQUENCE_START_EVENT:
			s->state = STATE_FVALUES;
			break;
		case YAML_MAPPING_END_EVENT:
			s->state = STATE_SECTION;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FVALUES:
		switch (event->type) {
		case YAML_MAPPING_START_EVENT:
			s->state = STATE_FKEY;
			break;
		case YAML_SEQUENCE_END_EVENT:
			s->state = STATE_FLIST;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_ILIST:
		switch (event->type) {
		case YAML_SEQUENCE_START_EVENT:
			s->state = STATE_IVALUES;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_IVALUES:
		switch (event->type) {
		case YAML_MAPPING_START_EVENT:
			s->state = STATE_IKEY;
			break;
		case YAML_SEQUENCE_END_EVENT:
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FKEY:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			value = (char *) event->data.scalar.value;
			if(strcmp(value, "name") == 0) {
				s->state = STATE_FNAME;
			} else if(strcmp(value, "disk") == 0) {
				s->state = STATE_FDISK;
			} else if(strcmp(value, "runtime") == 0) {
				s->state = STATE_FRUNTIME;
			} else if(strcmp(value, "net") == 0) {
				s->state = STATE_FNET;
			} else if(strcmp(value, "args") == 0) {
				s->state = STATE_FARGS;
			} else if(strcmp(value, "wait") == 0) {
				s->state = STATE_FWAIT;
			} else if(strcmp(value, "clean_room") == 0) {
				s->state = STATE_FCR;
			} else if(strcmp(value, "callback_in") == 0) {
				s->state = STATE_FCALLBACK_IN;
			} else if(strcmp(value, "callback_out") == 0) {
				s->state = STATE_FCALLBACK_OUT;
			} else if(strcmp(value, "isolation") == 0) {
				s->state = STATE_ILIST;
			} else {
				fprintf(stderr, "Unexpected key: %s\n", value);
				return FAILURE;
			}
			break;
		case YAML_MAPPING_END_EVENT:
			add_cvm(&s->flist, s->f.name, s->f.disk, s->f.runtime, s->f.net, s->f.args, s->f.isol.base, s->f.isol.size, s->f.isol.begin, s->f.isol.end, s->f.cb_out, s->f.cb_in, s->f.wait,
				s->f.cr);
			free(s->f.name);
			free(s->f.disk);
			free(s->f.runtime);
			free(s->f.net);
			free(s->f.args);
			free(s->f.cb_in);
			free(s->f.cb_out);
			memset(&s->f, 0, sizeof(s->f));
			s->state = STATE_FVALUES;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FNAME:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.name) {
				fprintf(stderr, "Warning: duplicate 'name' key.\n");
				free(s->f.name);
			}
			s->f.name = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FDISK:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.disk) {
				fprintf(stderr, "Warning: duplicate 'disk' key.\n");
				free(s->f.disk);
			}
			s->f.disk = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FRUNTIME:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.runtime) {
				fprintf(stderr, "Warning: duplicate 'runtime' key.\n");
				free(s->f.runtime);
			}
			s->f.runtime = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FNET:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.net) {
				fprintf(stderr, "Warning: duplicate 'net' key.\n");
				free(s->f.net);
			}
			s->f.net = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FWAIT:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->f.wait = strtol((char *) event->data.scalar.value, NULL, 10);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FCR:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->f.cr = strtol((char *) event->data.scalar.value, NULL, 10);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FARGS:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.args) {
				fprintf(stderr, "Warning: duplicate 'args' key.\n");
				free(s->f.args);
			}
			s->f.args = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FCALLBACK_IN:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.cb_in) {
				fprintf(stderr, "Warning: duplicate 'callback_in' key.\n");
				free(s->f.cb_in);
			}
			s->f.cb_in = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_FCALLBACK_OUT:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->f.cb_out) {
				fprintf(stderr, "Warning: duplicate 'callback_out' key.\n");
				free(s->f.cb_out);
			}
			s->f.cb_out = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_FKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

////////
	case STATE_IKEY:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			value = (char *) event->data.scalar.value;
			if(strcmp(value, "base") == 0) {
				s->state = STATE_IBASE;
			} else if(strcmp(value, "size") == 0) {
				s->state = STATE_ISIZE;
			} else if(strcmp(value, "begin") == 0) {
				s->state = STATE_IBEGIN;
			} else if(strcmp(value, "end") == 0) {
				s->state = STATE_IEND;
			} else {
				fprintf(stderr, "Unexpected key: %s\n", value);
				return FAILURE;
			}
			break;
		case YAML_MAPPING_END_EVENT:
			s->state = STATE_IVALUES;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_IBASE:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->f.isol.base = strtol((char *) event->data.scalar.value, NULL, 16);
			s->state = STATE_IKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_ISIZE:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->f.isol.size = strtol((char *) event->data.scalar.value, NULL, 16);
			s->state = STATE_IKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_IBEGIN:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->f.isol.begin = strtol((char *) event->data.scalar.value, NULL, 16);
			s->state = STATE_IKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_IEND:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->f.isol.end = strtol((char *) event->data.scalar.value, NULL, 16);
			s->state = STATE_IKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

//////////////////////////
	case STATE_CLIST:
		switch (event->type) {
		case YAML_SEQUENCE_START_EVENT:
			s->state = STATE_CVALUES;
			break;
		case YAML_MAPPING_END_EVENT:
			s->state = STATE_SECTION;
			break;
		case YAML_SCALAR_EVENT:
			printf("something is wrong %s\n", (char *) event->data.scalar.value);
			while(1) ;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_CVALUES:
		switch (event->type) {
		case YAML_MAPPING_START_EVENT:
			s->state = STATE_CKEY;
			break;
		case YAML_SEQUENCE_END_EVENT:
			s->state = STATE_CLIST;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_CKEY:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			value = (char *) event->data.scalar.value;
			if(strcmp(value, "name") == 0) {
				s->state = STATE_CNAME;
			} else if(strcmp(value, "data") == 0) {
				s->state = STATE_CDATA;
			} else if(strcmp(value, "size") == 0) {
				s->state = STATE_CSIZE;
			} else if(strcmp(value, "addr") == 0) {
				s->state = STATE_CADDR;
			} else {
				fprintf(stderr, "Unexpected key: %s\n", value);
				return FAILURE;
			}
			break;
		case YAML_MAPPING_END_EVENT:
			add_capfile(&s->clist, s->c.name, s->c.data, s->c.size, s->c.addr);
			free(s->c.name);
			free(s->c.data);
			memset(&s->c, 0, sizeof(s->c));
			s->state = STATE_CVALUES;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_CNAME:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->c.name) {
				fprintf(stderr, "Warning: duplicate 'name' key.\n");
				free(s->c.name);
			}
			s->c.name = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_CKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_CDATA:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			if(s->c.data) {
				fprintf(stderr, "Warning: duplicate 'data' key.\n");
				free(s->c.data);
			}
			s->c.data = bail_strdup((char *) event->data.scalar.value);
			s->state = STATE_CKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_CSIZE:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->c.size = strtol((char *) event->data.scalar.value, NULL, 16);
			s->state = STATE_CKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

	case STATE_CADDR:
		switch (event->type) {
		case YAML_SCALAR_EVENT:
			s->c.addr = strtol((char *) event->data.scalar.value, NULL, 16);
			s->state = STATE_CKEY;
			break;
		default:
			fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
			return FAILURE;
		}
		break;

//////////////////////////

	case STATE_STOP:
		break;
	}
	return SUCCESS;
}

struct parser_state state;

struct parser_state *run_yaml_scenario(char *yaml_cfg) {
	int code;
	enum status status;
	yaml_parser_t parser;
	yaml_event_t event;

	memset(&state, 0, sizeof(state));
	state.state = STATE_START;
	yaml_parser_initialize(&parser);

	FILE *in = fopen(yaml_cfg, "r");

	if(in == 0) {
		printf("cannot open %s, die\n", yaml_cfg);
	}

	yaml_parser_set_input_file(&parser, in);
	do {
		status = yaml_parser_parse(&parser, &event);
		if(status == FAILURE) {
			fprintf(stderr, "yaml_parser_parse error\n");
			code = EXIT_FAILURE;
			goto done;
		}
		status = consume_event(&state, &event);
		if(status == FAILURE) {
			fprintf(stderr, "consume_event error\n");
			code = EXIT_FAILURE;
			goto done;
		}
		yaml_event_delete(&event);
	} while(state.state != STATE_STOP);

	return &state;

      done:
	fclose(in);
	free(state.f.name);
	free(state.f.disk);
	free(state.f.runtime);
	free(state.f.net);
	free(state.f.args);
	destroy_cvms(&state.flist);
	yaml_parser_delete(&parser);

	return 0;
}
